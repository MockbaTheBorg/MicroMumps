; ===========================================================================
; UC Davis MicroMumps for CP/M - version 4.06
; Rebuilt by Marcelo F. Dantas in February of 2014
; marcelo.f.dantas@gmail.com
; ===========================================================================
;
include 'HEAD.Z80'
;
                org 100h
; =============== S U B R O U T I N E =======================================
                ; public start
start:
                ld      hl, 0
                add     hl, sp
                ld      (SaveSP), hl
                ld      hl, DiskBuf
                ld      sp, hl
                ld      c, PrintString
                ld      de, sGreet
                call    BDOS
rMumpsDR:
                ld      c, PrintString
                ld      de, sEnterDrive
                call    BDOS
                call    ReadDR
                jp      c, rMumpsDR
                cp      -1
                jp      z, rMumpsDR
                ld      (MumpsDrive), a
                ld      e, a
                ld      c, SelectDisk
                call    BDOS
                ld      c, OpenFile
                ld      de, Page0FCB
                call    BDOS
                inc     a
                jp      nz, Continue
                ld      c, PrintString
                ld      de, sTryingName
                call    BDOS
                ld      hl, sMUMPS
                ld      de, Page0FCB+1
                ld      bc, 11
                ldir
                ld      a, (MumpsDrive)
                ld      e, a
                ld      c, SelectDisk
                call    BDOS
                ld      c, OpenFile
                ld      de, Page0FCB
                call    BDOS
                inc     a
                jp      z, rMumpsDR
Continue:
                ld      hl, DiskBuf
                ld      (DiskBufLoc), hl
                xor     a
                ld      (FileReg), a
                ld      b, 4
ReadSecs:
                push    bc
                ld      c, SetDMA
                ld      hl, (DiskBufLoc)
                ex      de, hl
                call    BDOS
                ld      c, ReadNext
                ld      de, Page0FCB
                call    BDOS
                ld      hl, (DiskBufLoc)
                ld      de, 128
                add     hl, de
                ld      (DiskBufLoc), hl
                pop     bc
                dec     b
                jp      nz, ReadSecs
rPartition:
                ld      c, PrintString
                ld      de, sEnterPSize
                call    BDOS
                ld      hl, (PartSize)
                call    HLtoInt
                ld      c, PrintString
                ld      de, sEnterPSize2
                call    BDOS
                ld      c, BufferIn
                ld      de, iBuffer
                call    BDOS
                ld      de, Buffer
                ld      a, (de)
                cp      6
                jp      nc, InvPart
                or      a
                jp      z, ReadGDrive
                ld      c, a
                inc     de
                ld      hl, 0
CkPart:
                ld      a, (de)
                push    de
                cp      '0'
                jp      c, rPartition
                cp      ':'
                jp      nc, rPartition
                and     1111b
                push    hl
                add     hl, hl
                jp      c, CkPart1
                add     hl, hl
                jp      c, CkPart1
                pop     de
                add     hl, de
                jp      c, CkPart2
                add     hl, hl
                jp      c, CkPart2
                ld      e, a
                ld      d, 0
                add     hl, de
                pop     de
                inc     de
                dec     c
                jp      nz, CkPart
                jp      CkFree
CkPart1:
                pop     hl
CkPart2:
                pop     hl
InvPart:
                ld      de, sInvalidPSize
                ld      c, PrintString
                call    BDOS
                jp      rPartition
CkFree:
                ld      (PartSize), hl
                ex      de, hl
                ld      hl, (LastByte)
                add     hl, de
                jp      c, CkFree1
                ex      de, hl
                ld      hl, (6)
                dec     hl
                ld      a, l
                sub     e
                ld      l, a
                ld      a, h
                sbc     a, d
                ld      h, a
                jp      nc, CkRoom
CkFree1:
                ld      de, sTooLarge
CkFree2:
                ld      c, PrintString
                call    BDOS
                jp      rPartition
CkRoom:
                ld      de, 1058
                ld      a, l
                sub     e
                ld      a, h
                sbc     a, d
                jp      nc, CkLeaves
                ld      de, sNoRoom
                jp      CkFree2
CkLeaves:
                push    hl
                ld      de, sThatLeaves
                ld      c, PrintString
                call    BDOS
                pop     hl
                call    HLtoInt
                ld      de, sBytes
                ld      c, PrintString
                call    BDOS
AskRoom:
                ld      de, sEnoughRoom
                call    YesNo
                jp      c, AskRoom
                jp      z, ReadGDrive
                cp      'N'
                jp      z, rPartition
ReadGDrive:
                ld      hl, GlobalDrive
                ld      de, sGlbDrv
                call    ReadDrive
                jp      c, ReadGDrive
                jp      z, ReadRDrive
                ld      (GlobalDrive), a
ReadRDrive:
                ld      hl, RoutineDrive
                ld      de, sRoutineDrv
                call    ReadDrive
                jp      c, ReadRDrive
                jp      z, ReadEDrive
                ld      (RoutineDrive), a
ReadEDrive:
                ld      hl, ErrorDrive
                ld      de, sErrDrv
                call    ReadDrive
                jp      c, ReadEDrive
                jp      z, ReadMFN
                ld      (ErrorDrive), a
ReadMFN:
                ld      de, sErrName
                ld      c, PrintString
                call    BDOS
                ld      c, BufferIn
                ld      de, iBuffer
                call    BDOS
                ld      hl, Buffer
                ld      a, (hl)
                or      a
                jp      z, ReadAEYN
                inc     hl
                ld      c, a
                ld      de, ErrorFName
                ld      a, ' '
                ld      b, 11
ReadMFN1:
                ld      (de), a
                inc     de
                dec     b
                jp      nz, ReadMFN1
                ld      de, ErrorFName
                ld      b, 8
ReadMFN2:
                ld      a, (hl)
                cp      '.'
                jp      z, ReadMFN4
                cp      'a'
                jp      c, ReadMFN3
                cp      '{'
                jp      nc, ReadMFN3
                and     11011111b
ReadMFN3:
                ld      (de), a
                inc     de
                inc     hl
                dec     c
                jp      z, ReadAEYN
                dec     b
                jp      nz, ReadMFN2
                ld      a, (hl)
                cp      '.'
                jp      nz, ReadAEYN
ReadMFN4:
                inc     hl
                dec     c
                push    bc
                ld      c, b
                ld      b, 0
                ex      de, hl
                add     hl, bc
                ex      de, hl
                pop     bc
                ld      b, 3
                jp      ReadMFN2
ReadAEYN:
                ld      de, sAutoExec
                call    YesNo
                jp      c, ReadAEYN
                jp      z, WriteChg
                cp      'N'
                jp      z, WriteChg
                ld      c, PrintString
                ld      de, sMumpsCmds
                call    BDOS
                ld      c, BufferIn
                ld      de, iAutoexec
                ld      a, 0FFh
                ld      (de), a
                call    BDOS
                ld      de, Autoexec
                ld      a, (de)
                or      a
                jp      z, ReadAEYN1
                ld      h, 0
                ld      l, a
                add     hl, de
                inc     hl
                ld      (hl), 13
                ld      a, 1
ReadAEYN1:
                dec     de
                ld      (de), a
WriteChg:
                ld      hl, DiskBuf
                ld      (DiskBufLoc), hl
                xor     a
                ld      (FileReg), a
                ld      b, 4
WriteChg1:
                push    bc
                ld      c, SetDMA
                ld      hl, (DiskBufLoc)
                ex      de, hl
                call    BDOS
                ld      c, WriteNext
                ld      de, Page0FCB
                call    BDOS
                ld      hl, (DiskBufLoc)
                ld      de, 128
                add     hl, de
                ld      (DiskBufLoc), hl
                pop     bc
                dec     b
                jp      nz, WriteChg1
                ld      c, PrintString
                ld      de, sSaved
                call    BDOS
                ld      hl, (SaveSP)
                ld      sp, hl
                jp      BOOT
; End of function start
; =============== S U B R O U T I N E =======================================
ReadDR:
                ld      c, BufferIn
                ld      de, iBuffer
                call    BDOS
                ld      hl, Buffer
                ld      a, (hl)
                or      a
                jp      z, ReadDR2
                cp      1
                jp      nz, ReadDR1
                inc     hl
                ld      a, (hl)
                and     11011111b
                cp      'A'
                ret     c
                cp      'Q'
                jp      nc, ReadDR1
                sub     'A'
                ret
ReadDR1:
                scf
                ret
ReadDR2:
                ld      a, -1
                ret
; End of function ReadDR
; =============== S U B R O U T I N E =======================================
ReadDrive:
                push    hl
                ld      c, PrintString
                call    BDOS
                pop     hl
                ld      a, (hl)
                add     a, 'A'
                ld      e, a
                ld      c, ConsoleOut
                call    BDOS
                ld      c, PrintString
                ld      de, sEnterPSize2
                call    BDOS
                call    ReadDR
                ret     c
                cp      -1
                jp      nc, ReadDrive1
                ccf
ReadDrive1:
                ret
; End of function ReadDrive
; =============== S U B R O U T I N E =======================================
HLtoInt:
                ld      de, 10000
                ld      bc, 0
HLtoInt1:
                ld      a, l
                sub     e
                ld      l, a
                ld      a, h
                sbc     a, d
                ld      h, a
                jp      c, HLtoInt2
                inc     b
                jp      HLtoInt1
HLtoInt2:
                add     hl, de
                ld      a, b
                or      c
                jp      z, HLtoInt3
                ld      a, b
                or      30h ; '0'
                push    hl
                push    de
                push    bc
                ld      e, a
                ld      c, ConsoleOut
                call    BDOS
                pop     bc
                pop     de
                pop     hl
                inc     c
HLtoInt3:
                ld      b, 0
                ld      a, e
                cp      10
                jp      z, HLtoInt6
                cp      100
                jp      z, HLtoInt4
                cp      232
                jp      z, HLtoInt5
                ld      de, 1000
                jp      HLtoInt1
HLtoInt4:
                ld      de, 10
                jp      HLtoInt1
HLtoInt5:
                ld      de, 100
                jp      HLtoInt1
HLtoInt6:
                ld      a, l
                or      30h ; '0'
                ld      e, a
                ld      c, ConsoleOut
                call    BDOS
                ret
; End of function HLtoInt
; =============== S U B R O U T I N E =======================================
YesNo:
                ld      c, PrintString
                call    BDOS
                ld      c, BufferIn
                ld      de, iBuffer
                call    BDOS
                ld      hl, Buffer
                ld      a, (hl)
                or      a
                ret     z
                inc     hl
                ld      a, (hl)
                and     11011111b
                cp      'N'
                jp      z, YesNo1
                cp      'Y'
                jp      nz, yesNo2
YesNo1:
                or      a
                ret
yesNo2:
                scf
                ret
; End of function YesNo
sMUMPS:         db 'MUMPS   COM'
sTryingName:    db 0Dh,0Ah
                db 'Trying default name MUMPS.COM...$'
sNotFound:      db 0Dh,0Ah
                db 'Executable not found.$'
sGreet:         db 'SetMumps v4.06 for Z80 Mumps CP/M',0Dh,0Ah
                db 'rebuilt in Feb/2014 by Marcelo Dantas',0Dh,0Ah
                db 'marcelo.f.dantas@gmail.com',0Dh,0Ah,'$'
sEnterDrive:    db 0Dh,0Ah
                db 'Enter drive of the MUMPS.COM to change: $'
sEnterPSize:    db 0Dh,0Ah
                db 'Enter partition size in bytes ($'
sEnterPSize2:   db '): $'
sThatLeaves:    db 0Dh,0Ah
                db 'That leaves $'
sTooLarge:      db 0Dh,0Ah
                db 'Partition is too large--try again',0Dh,0Ah,'$'
sAutoExec:      db 0Dh,0Ah
                db 'Do you want to change the auto-execute command? (Y/N) $'
sMumpsCmds:     db 0Dh,0Ah
                db 'Enter the mumps commands to auto-execute',0Dh,0Ah,'$'
sSaved:         db 0Dh,0Ah
                db 0Ah
                db 'The new configuration of MUMPS is saved',0Dh,0Ah,'$'
sGlbDrv:        db 0Dh,0Ah
                db 'Enter default GLOBAL drive ($'
sRoutineDrv:    db 0Dh,0Ah
                db 'Enter default ROUTINE drive ($'
sErrDrv:        db 0Dh,0Ah
                db 'Enter default ERROR MESSAGE drive ($'
sBytes:         db ' bytes for ROUTINE and GLOBAL buffers',0Dh,0Ah,'$'
sErrName:       db 0Dh,0Ah
                db 'Enter name for new ERROR MESSAGE file: $'
sInvalidPSize:  db 0Dh,0Ah
                db 'Invalid partition size$'
sEnoughRoom:    db 0Dh,0Ah
                db 'Is that enough room? (Y/N) $'
sNoRoom:        db 0Dh,0Ah
                db 'Not enough room for GLOBAL buffers$'
DiskBufLoc:     dw 0
SaveSP:         dw 0
MumpsDrive:     db 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
iBuffer:        db 0Bh
Buffer:         db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0
DiskBuf:        db 0
                db 0, 0, 0, 0, 0, 0
GlobalDrive:    db 0
RoutineDrive:   db 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0
LastByte:       db 0
                db 0
PartSize:       dw 0
ErrorDrive:     db 0
ErrorFCB:       db 0
ErrorFName:     db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
iAutoexec:      db 0
Autoexec:       db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0
; end of 'seg000'
                end ; start
