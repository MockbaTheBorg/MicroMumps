; ===========================================================================
; UC Davis MicroMumps for CP/M - version 4.06
; Rebuilt by Marcelo F. Dantas in February of 2014
; marcelo.f.dantas@gmail.com
; ===========================================================================
;
include 'HEAD.Z80'
;
                org 100h
; =============== S U B R O U T I N E =======================================
                ; public start
start:
                ld      hl, 0
                add     hl, sp
                ld      (SaveSP), hl
                ld      hl, Stack
                ld      sp, hl
                ld      c, PrintString
                ld      de, sGreet
                call    BDOS
rGlobDr:
                ld      c, PrintString
                ld      de, sEnterDrive
                call    BDOS
                call    ReadDR
                jp      c, rGlobDr
                cp      -1
                jp      z, rGlobDr
                ld      e, a
                ld      c, SelectDisk
                call    BDOS
                ld      c, OpenFile
                ld      de, GlobalsFCB
                call    BDOS
                inc     a
                jp      z, rFileSize
                ld      c, PrintString
                ld      de, sAlreadyExists
                call    BDOS
                jp      rGlobDr
rFileSize:
                ld      c, PrintString
                ld      de, sEnterSize1
                call    BDOS
                ld      hl, (DefaultSize)
                call    HLtoInt
                ld      c, PrintString
                ld      de, sEnterSize2
                call    BDOS
                call    ReadNum
                jp      c, rFileSize
                cp      -1
                jp      nz, rFileSize1
                ld      hl, (DefaultSize)
rFileSize1:
                dec     hl
                ld      a, h
                or      l
                jp      z, rFileSize
                ld      (NumBlocks), hl
rAllocate:
                ld      c, PrintString
                ld      de, sAllocate
                call    BDOS
                call    ReadYesNo
                jp      c, rAllocate
                ld      (fAllocate), a
BitMap:
                ld      hl, (NumBlocks)
                ex      de, hl
                ld      hl, Bitmap
                xor     a
                ld      b, a
                jp      BitMap2
BitMap1:
                ld      a, b
                or      128
                ld      b, a
                dec     de
                ld      a, d
                or      e
                jp      z, WriteFile
BitMap2:
                ld      a, b
                or      64
                ld      b, a
                dec     de
                ld      a, d
                or      e
                jp      z, WriteFile
BitMap3:
                ld      a, b
                or      32
                ld      b, a
                dec     de
                ld      a, d
                or      e
                jp      z, WriteFile
BitMap4:
                ld      a, b
                or      16
                ld      b, a
                dec     de
                ld      a, d
                or      e
                jp      z, WriteFile
BitMap5:
                ld      a, b
                or      8
                ld      b, a
                dec     de
                ld      a, d
                or      e
                jp      z, WriteFile
BitMap6:
                ld      a, b
                or      4
                ld      b, a
                dec     de
                ld      a, d
                or      e
                jp      z, WriteFile
BitMap7:
                ld      a, b
                or      2
                ld      b, a
                dec     de
                ld      a, d
                or      e
                jp      z, WriteFile
BitMap8:
                ld      a, b
                or      1
                ld      b, a
                dec     de
                ld      a, d
                or      e
                jp      z, WriteFile
BitMap9:
                ld      (hl), b
                xor     a
                ld      b, a
                inc     hl
                jp      BitMap1
WriteFile:
                ld      (hl), b
                ld      c, PrintString
                ld      de, sCreating
                call    BDOS
                ld      c, MakeFile
                ld      de, GlobalsFCB
                call    BDOS
                jp      nz, MakeError
                ld      de, Block0
                call    WriteBlock
                ld      de, Block1
                call    WriteBlock
                ld      de, Block2
                call    WriteBlock
                ld      de, Block3
                call    WriteBlock
                ld      de, Block4
                call    WriteBlock
                ld      de, Block5
                call    WriteBlock
                ld      a, (fAllocate)
                cp      'N'
                jp      z, Done
                ld      de, (NumBlocks)
rAllocateAll:
                push    de
                ld      de, EmptyBlock
                call    WriteBlock
                ld      de, EmptyBlock
                call    WriteBlock
                ld      de, EmptyBlock
                call    WriteBlock
                ld      de, EmptyBlock
                call    WriteBlock
                ld      de, EmptyBlock
                call    WriteBlock
                ld      de, EmptyBlock
                call    WriteBlock
                pop     de
                dec     de
                ld      a, d
                or      e
                jp      nz, rAllocateAll
Done:
                ld      c, CloseFile
                ld      de, GlobalsFCB
                call    BDOS
                cp      -1
                jp      z, CloseError
                ld      c, PrintString
                ld      de, sDone
                call    BDOS
                jp      Finished
MakeError:
                ld      de, sMakeError
                jp      Error
WriteError:
                ld      de, sWriteError
                jp      Error
CloseError:
                ld      de, sCloseError
Error:
                ld      c, PrintString
                call    BDOS
Finished:
                ld      c, PrintString
                ld      de, sNewLine
                call    BDOS
                ld      hl, (SaveSP)
                ld      sp, hl
                jp      BOOT
; End of function start
; =============== S U B R O U T I N E =======================================
WriteBlock:
                ld      c, SetDMA
                call    BDOS
                ld      c, WriteNext
                ld      de, GlobalsFCB
                call    BDOS
                or      a
                jp      nz, WriteError
                ret
; End of function WriteBlock
; =============== S U B R O U T I N E =======================================
ReadDR:
                ld      a, 1
                ld      (iBuffer), a
                ld      c, BufferIn
                ld      de, iBuffer
                call    BDOS
                ld      hl, Buffer
                ld      a, (hl)
                or      a
                jp      z, ReadDRErr2
                cp      1
                jp      nz, ReadDRErr1
                inc     hl
                ld      a, (hl)
                and     11011111b
                cp      'A'
                ret     c
                cp      'Q'
                jp      nc, ReadDRErr1
                sub     'A'
                ret
ReadDRErr1:
                scf
                ret
ReadDRErr2:
                ld      a, -1
                ret
; End of function ReadDR
; =============== S U B R O U T I N E =======================================
ReadNum:
                ld      a, 5
                ld      (iBuffer), a
                ld      c, BufferIn
                ld      de, iBuffer
                call    BDOS
                ld      de, Buffer
                ld      a, (de)
                or      a
                jp      z, ReadNumErr2
                cp      6
                jp      nc, ReadNumErr1
                ld      c, a
                inc     de
                ld      hl, 0
ReadNum1:
                ld      a, (de)
                push    de
                cp      '0'
                jp      c, ReadNumErr1
                cp      ':'
                jp      nc, ReadNumErr1
                and     1111b
                push    hl
                add     hl, hl
                jp      c, ReadNumErr1
                add     hl, hl
                jp      c, ReadNumErr1
                pop     de
                add     hl, de
                jp      c, ReadNumErr1
                add     hl, hl
                jp      c, ReadNumErr1
                ld      e, a
                ld      d, 0
                add     hl, de
                pop     de
                inc     de
                dec     c
                jp      nz, ReadNum1
                ld      a, h
                or      l
                jp      z, ReadNumErr1
                ld      de, (MaxBlocks)
                ld      a, e
                sub     l
                ld      a, d
                sbc     a, h
                jp      c, ReadNumErr1
                ret
ReadNumErr1:
                scf
                ret
ReadNumErr2:
                ld      a, -1
                ret
; End of function ReadNum
; =============== S U B R O U T I N E =======================================
ReadYesNo:
                ld      a, 1
                ld      (iBuffer), a
                ld      c, BufferIn
                ld      de, iBuffer
                call    BDOS
                ld      hl, Buffer
                ld      a, (hl)
                or      a
                ret     z
                inc     hl
                ld      a, (hl)
                and     11011111b
                cp      'N'
                jp      z, ReadYesNo1
                cp      'Y'
                jp      nz, ReadYesNo2
ReadYesNo1:
                or      a
                ret
ReadYesNo2:
                scf
                ret
; End of function ReadYesNo
; =============== S U B R O U T I N E =======================================
HLtoInt:
                ld      de, 10000
                ld      bc, 0
HLtoInt1:
                ld      a, l
                sub     e
                ld      l, a
                ld      a, h
                sbc     a, d
                ld      h, a
                jp      c, HLtoInt2
                inc     b
                jp      HLtoInt1
HLtoInt2:
                add     hl, de
                ld      a, b
                or      c
                jp      z, HLtoInt3
                ld      a, b
                or      30h ; '0'
                push    hl
                push    de
                push    bc
                ld      e, a
                ld      c, ConsoleOut
                call    BDOS
                pop     bc
                pop     de
                pop     hl
                inc     c
HLtoInt3:
                ld      b, 0
                ld      a, e
                cp      10
                jp      z, HLtoInt6
                cp      100
                jp      z, HLtoInt4
                cp      232
                jp      z, HLtoInt5
                ld      de, 1000
                jp      HLtoInt1
HLtoInt4:
                ld      de, 10
                jp      HLtoInt1
HLtoInt5:
                ld      de, 100
                jp      HLtoInt1
HLtoInt6:
                ld      a, l
                or      30h ; '0'
                ld      e, a
                ld      c, ConsoleOut
                call    BDOS
                ret
; End of function HLtoInt
sGreet:         db 'SetGlob v4.06 for Z80 Mumps CP/M',0Dh,0Ah
                db 'rebuilt in Feb/2014 by Marcelo Dantas',0Dh,0Ah
                db 'marcelo.f.dantas@gmail.com',0Dh,0Ah,'$'
sEnterDrive:    db 0Dh,0Ah
                db 'Enter drive to create the GLOBALS.DAT on: $'
sAlreadyExists: db 0Dh,0Ah
                db 'File aready exists on that drive.$'
sEnterSize1:    db 0Dh,0Ah
                db 'Enter the file size in mumps blocks ($'
sEnterSize2:    db '): $'
sAllocate:      db 0Dh,0Ah
                db 'Allocate the entire file now (Y/N)? $'
sCreating:      db 0Dh,0Ah
                db 'Creating GLOBALS.DAT ... $'
sDone:          db 'Done.$'
sMakeError:     db 'Creation error.$'
sWriteError:    db 'Write error.$'
sCloseError:    db 'Close error.$'
sNewLine:       db 0Dh,0Ah,'$'
DefaultSize:    dw 200
GlobalsFCB:     db 0
                db 'GLOBALS DAT'
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0
BlockSize:      dw 300h
MaxBlocks:      dw 11000
Block0:         db -1
                dw -1
                dw 1
NumBlocks:      dw 0
Bitmap:         db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
Block1:         db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0
Block2:         db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0
Block3:         db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0
Block4:         db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0
Block5:         db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0
EmptyBlock:     db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0
SaveSP:         dw 0
fAllocate:      db 0
iBuffer:        db 1
Buffer:         db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
Stack:          db '$'
; end of 'seg000'
                end ; start
